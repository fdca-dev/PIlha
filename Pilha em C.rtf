{\rtf1\ansi\deff3\adeflang1025
{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}{\f1\froman\fprq2\fcharset2 Symbol;}{\f2\fswiss\fprq2\fcharset0 Arial;}{\f3\froman\fprq2\fcharset0 Liberation Serif{\*\falt Times New Roman};}{\f4\fswiss\fprq2\fcharset0 Liberation Sans{\*\falt Arial};}{\f5\fnil\fprq2\fcharset0 Microsoft YaHei;}{\f6\fnil\fprq2\fcharset0 NSimSun;}{\f7\fswiss\fprq0\fcharset128 Lucida Sans;}{\f8\fnil\fprq2\fcharset0 Lucida Sans;}}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet{\s0\snext0\rtlch\af8\afs24\alang1081 \ltrch\lang1046\langfe2052\hich\af3\loch\nowidctlpar\hyphpar0\ltrpar\cf0\f3\fs24\lang1046\kerning1\dbch\af6\langfe2052 Normal;}
{\s2\sbasedon15\snext16\rtlch\af8\afs36\ab \ltrch\hich\af3\loch\ilvl1\outlinelevel1\sb200\sa120\keepn\f3\fs36\b\dbch\af6 Heading 2;}
{\s3\sbasedon15\snext16\rtlch\af8\afs28\ab \ltrch\hich\af3\loch\ilvl2\outlinelevel2\sb140\sa120\keepn\f3\fs28\b\dbch\af6 Heading 3;}
{\s15\sbasedon0\snext16\rtlch\af8\afs28 \ltrch\hich\af4\loch\sb240\sa120\keepn\f4\fs28\dbch\af5 T\u237\'edtulo;}
{\s16\sbasedon0\snext16\loch\sl276\slmult1\sb0\sa140 Body Text;}
{\s17\sbasedon16\snext17\rtlch\af7 \ltrch\loch\sl276\slmult1\sb0\sa140 List;}
{\s18\sbasedon0\snext18\rtlch\af7\afs24\ai \ltrch\loch\sb120\sa120\noline\fs24\i Caption;}
{\s19\sbasedon0\snext19\rtlch\af7 \ltrch\loch\noline \u205\'cdndice;}
{\s20\sbasedon0\snext20\loch\nowidctlpar\noline Conte\u250\'fado da tabela;}
{\s21\sbasedon20\snext21\rtlch\ab \ltrch\loch\qc\nowidctlpar\noline\b T\u237\'edtulo de tabela;}
}{\*\generator LibreOffice/7.6.6.3$Windows_X86_64 LibreOffice_project/d97b2716a9a4a2ce1391dee1765565ea469b0ae7}{\info{\creatim\yr0\mo0\dy0\hr0\min0}{\revtim\yr2024\mo5\dy20\hr0\min1}{\printim\yr0\mo0\dy0\hr0\min0}}{\*\userprops}\deftab709
\hyphauto1\viewscale100\formshade\paperh16838\paperw11906\margl1134\margr1134\margt1134\margb1134\sectd\sbknone\sftnnar\saftnnrlc\sectunlocked1\pgwsxn11906\pghsxn16838\marglsxn1134\margrsxn1134\margtsxn1134\margbsxn1134\ftnbj\ftnstart1\ftnrstcont\ftnnar\aenddoc\aftnrstcont\aftnstart1\aftnnrlc
{\*\ftnsep\chftnsep}\pgndec\pard\plain \s2\rtlch\af8\afs36\ab \ltrch\hich\af3\loch\ilvl1\outlinelevel1\sb200\sa120\keepn\f3\fs36\b\dbch\af6\ql\sb200\sa120\ltrpar{\loch
Como Programar Uma }{\loch\cf6\loch
Pilha em C}
\par \pard\plain \s16\loch\sl276\slmult1\sb0\sa140\ql\fi0\li0\lin0\ri75\rin75\ltrpar{\loch
Aqui, vamos explicando, passo a passo, como criar uma }{\loch\b\loch
pilha em C}{\loch
, do zero, na m\u227\'e3o.\line Inicialmente vamos comentar tudo que \u233\'e9 necess\u225\'e1rio, toda a l\u243\'f3gica, e o c\u243\'f3digo ser\u225\'e1 exibido na pr\u243\'f3xima parte deste tutorial.}
\par \pard\plain \s3\rtlch\af8\afs28\ab \ltrch\hich\af3\loch\ilvl2\outlinelevel2\sb140\sa120\keepn\f3\fs28\b\dbch\af6\ql\ltrpar{\loch
Struct e Cabe\u231\'e7alhos de Fun\u231\'e7\u245\'f5es}
\par \pard\plain \s16\loch\sl276\slmult1\sb0\sa140\ql\ltrpar{\loch
O primeiro passo \u233\'e9 a struct, vamos de Node (cada elemento de uma pilha \u233\'e9 chamado de n\u243\'f3).\line Ela vai ter apenas dois elementos, um n\u250\'famero inteiro e um ponteiro para outra struct do tipo Node.\line \line Esse ponteiro do pr\u243\'f3prio tipo \u233\'e9 obrigat\u243\'f3rio, n\u227\'e3o existe estrutura din\u226\'e2mica de dados sem esse detalhe especial. Na l\u243\'f3gica do funcionamento da pilha, vamos entender para que ele serve.\line \line J\u225\'e1 o outro elemento (}{\loch\b\loch
int num}{\loch
) \u233\'e9 s\u243\'f3 para armazenarmos n\u250\'fameros nessa pilha, pois vamos pedir e mostrar esses n\u250\'fameros. Mas note que isso \u233\'e9 uma struct, podemos colocar quantos elementos e do tamanho que quisermos, que a pilha vai funcionar do mesmo jeito.\line \line Tamb\u233\'e9m colocamos todos os cabe\u231\'e7alhos das fun\u231\'e7\u245\'f5es que iremos usar para programar a pilha em C, por quest\u245\'f5es de organiza\u231\'e7\u227\'e3o (o c\u243\'f3digo das fun\u231\'e7\u245\'f5es ficar\u225\'e1 abaixo).}
\par \pard\plain \s3\rtlch\af8\afs28\ab \ltrch\hich\af3\loch\ilvl2\outlinelevel2\sb140\sa120\keepn\f3\fs28\b\dbch\af6\ql\ltrpar{\loch
Fun\u231\'e7\u227\'e3o main()}
\par \pard\plain \s16\loch\sl276\slmult1\sb0\sa140\ql\ltrpar{\loch
Na fun\u231\'e7\u227\'e3o main criamos a nossa pilha, que \u233\'e9 uma struct Node, vamos chamar ela de "PILHA", e \u233\'e9 a base. Quando o primeiro elemento for adicionado, ele vai ser adicionado no ponteiro "prox" da PILHA.\line Este n\u243\'f3, na verdade, n\u227\'e3o faz parte da pilha, ele serve apenas para indicar onde ela come\u231\'e7a (come\u231\'e7a no ponteiro na qual ela aponta).\line \line O resto da main \u233\'e9 simplesmente um la\u231\'e7o do while, que fica exibindo um menu com as op\u231\'e7\u245\'f5es para trabalharmos com a pilha, que termina se digitarmos 0.}
\par \pard\plain \s3\rtlch\af8\afs28\ab \ltrch\hich\af3\loch\ilvl2\outlinelevel2\sb140\sa120\keepn\f3\fs28\b\dbch\af6\ql\ltrpar{\loch
Fun\u231\'e7\u227\'e3o menu() e opcao()}
\par \pard\plain \s16\loch\sl276\slmult1\sb0\sa140\ql\ltrpar{\loch
Essas s\u227\'e3o as fun\u231\'e7\u245\'f5es respons\u225\'e1veis pela a\u231\'e7\u227\'e3o, a intera\u231\'e7\u227\'e3o o usu\u225\'e1rio e a pilha.\line \line A fun\u231\'e7\u227\'e3o menu() simplesmente exibe as op\u231\'e7\u245\'f5es poss\u237\'edveis e pede um inteiro ao usu\u225\'e1rio.\line Este inteiro ser\u225\'e1 usado e passado para a fun\u231\'e7\u227\'e3o opcao(), que junto com a pilha (ponteiro *PILHA) vai servir para chamar a fun\u231\'e7\u227\'e3o espec\u237\'edfica, de acordo com o que o usu\u225\'e1rio escolheu.\line \line Na fun\u231\'e7\u227\'e3o opcao(), basicamente existe um switch que vai tratar a op\u231\'e7\u227\'e3o escolhida pela usu\u225\'e1rio, e chamar a fun\u231\'e7\u227\'e3o correta. Sem segredo.}
\par \pard\plain \s3\rtlch\af8\afs28\ab \ltrch\hich\af3\loch\ilvl2\outlinelevel2\sb140\sa120\keepn\f3\fs28\b\dbch\af6\ql\ltrpar{\loch
Fun\u231\'e7\u227\'e3o inicia()}
\par \pard\plain \s16\loch\sl276\slmult1\sb0\sa140\ql\ltrpar{\loch
Esta fun\u231\'e7\u227\'e3o \u233\'e9 respons\u225\'e1vel por inicializar a pilha.\line Inicializar \u233\'e9 simplesmente preparar a pilha para ser utilizada, simplesmente apontando seu ponteiro *prox para NULL.\line \line Essa fun\u231\'e7\u227\'e3o \u233\'e9 chamada automaticamente no in\u237\'edcio de nosso programa em C, e quando zeramos a pilha.}
\par \pard\plain \s3\rtlch\af8\afs28\ab \ltrch\hich\af3\loch\ilvl2\outlinelevel2\sb140\sa120\keepn\f3\fs28\b\dbch\af6\ql\ltrpar{\loch
Fun\u231\'e7\u227\'e3o vazia()}
\par \pard\plain \s16\loch\sl276\slmult1\sb0\sa140\ql\ltrpar{\loch
Esta fun\u231\'e7\u227\'e3o simplesmente checa se a pilha est\u225\'e1 vazia ou n\u227\'e3o.\line Basta olhar para onde aponta a base (*PILHA), se apontar para NULL \u233\'e9 porque ela est\u225\'e1 vazia, sen\u227\'e3o, \u233\'e9 porque existem n\u243\'f3s nesta estrutura de dados din\u226\'e2mica.}
\par \pard\plain \s3\rtlch\af8\afs28\ab \ltrch\hich\af3\loch\ilvl2\outlinelevel2\sb140\sa120\keepn\f3\fs28\b\dbch\af6\ql\ltrpar{\loch
Fun\u231\'e7\u227\'e3o aloca()}
\par \pard\plain \s16\loch\sl276\slmult1\sb0\sa140\ql\ltrpar{\loch
Visando deixar nosso algoritmo bem feito, estruturado e organizado, \u233\'e9 interessante separar cada ideia em uma fun\u231\'e7\u227\'e3o diferente, com um prop\u243\'f3sito bem evidente e \u250\'fanico.\line \line A fun\u231\'e7\u227\'e3o aloca() \u233\'e9 um exemplo dessa organiza\u231\'e7\u227\'e3o.\line Como o nome sugere, ele serve para alocar n\u243\'f3s.\line Sempre que formos adicionar um elemento na pilha, temos que alocar mem\u243\'f3ria para ele.\line \line Essa fun\u231\'e7\u227\'e3o aloca a mem\u243\'f3ria necess\u225\'e1ria pro n\u243\'f3 (struct Node), pede o n\u250\'famero que o usu\u225\'e1rio quer armazenar) e retornar o endere\u231\'e7o da mem\u243\'f3ria alocada.}
\par \pard\plain \s3\rtlch\af8\afs28\ab \ltrch\hich\af3\loch\ilvl2\outlinelevel2\sb140\sa120\keepn\f3\fs28\b\dbch\af6\ql\ltrpar{\loch
Fun\u231\'e7\u227\'e3o libera()}
\par \pard\plain \s16\loch\sl276\slmult1\sb0\sa140\ql\ltrpar{\loch
T\u227\'e3o importante quanto alocar mem\u243\'f3ria para cada n\u243\'f3 da pilha de nossa estrutura de dados, \u233\'e9 liberar esse espa\u231\'e7o de mem\u243\'f3ria. A fun\u231\'e7\u227\'e3o libera faz isso, vai liberando o espa\u231\'e7o alocado de cada n\u243\'f3 de nossa pilha.\line \line Usamos dois ponteiros para a struct do n\u243\'f3, o ponteiro que aponta para o elemento atual e o ponteiro que aponta para o pr\u243\'f3ximo elemento.\line Pegamos o ponteiro que aponta para o n\u243\'f3 atual e usamos para desalocar aquele espa\u231\'e7o de mem\u243\'f3ria, em seguida o ponteiro que apontava para o atual aponta para o pr\u243\'f3ximo, e isso segue at\u233\'e9 o fim da pilha, desalocando cada um dos n\u243\'f3s da estrutura de dados.}
\par \pard\plain \s3\rtlch\af8\afs28\ab \ltrch\hich\af3\loch\ilvl2\outlinelevel2\sb140\sa120\keepn\f3\fs28\b\dbch\af6\ql\ltrpar{\loch
Fun\u231\'e7\u227\'e3o exibe()}
\par \pard\plain \s16\loch\sl276\slmult1\sb0\sa140\ql\ltrpar{\loch
Essa \u233\'e9 a fun\u231\'e7\u227\'e3o respons\u225\'e1vel por exibir todos os elementos da pilha.\line Como em cada n\u243\'f3 dessa estrutura de dados possui um inteiro que o usu\u225\'e1rio inseriu, essa fun\u231\'e7\u227\'e3o, no fim das contas, vai exibir os n\u250\'fameros da pilha.\line \line Essa fun\u231\'e7\u227\'e3o declara um ponteiro que vai come\u231\'e7ar apontando para o primeiro elemento da pilha, exibe o n\u250\'famero armazenado ali, pega o endere\u231\'e7o do pr\u243\'f3ximo n\u243\'f3, exibe o que est\u225\'e1 armazenado nele tamb\u233\'e9m, e assim se segue, at\u233\'e9 o fim da pilha (quando *prox aponta para NULL).}
\par \pard\plain \s3\rtlch\af8\afs28\ab \ltrch\hich\af3\loch\ilvl2\outlinelevel2\sb140\sa120\keepn\f3\fs28\b\dbch\af6\ql\ltrpar{\loch
Fun\u231\'e7\u227\'e3o push()}
\par \pard\plain \s16\loch\sl276\slmult1\sb0\sa140\ql\ltrpar{\loch
Agora vamos a parte que mais interessa em se tratando de estrutura de dados, e especificamente, sobre pilhas em C: as fun\u231\'e7\u245\'f5es push e pop.\line \line Push em ingl\u234\'eas \u233\'e9 empurrar, vamos empurrar, colocar um elemento, um n\u243\'f3 na pilha.\line O primeiro passo \u233\'e9 alocar espa\u231\'e7o para esteve novo n\u243\'f3 da pilha, o que \u233\'e9 feito com ajuda da fun\u231\'e7\u227\'e3o aloca().\line Como \u233\'e9 uma pilha, seu \u250\'faltimo elemento (que \u233\'e9 esteve novo), deve apontar para NULL, pois isso caracteriza o fim da pilha.\line \line Adicionado o elemento, vamos procurar o \u250\'faltimo elemento da pilha.\line Temos o ponteiro *PILHA que aponta para a base.\line Se a pilha estiver vazia, \u243\'f3timo! Fazemos o ponteiro *prox apontar para esteve novo n\u243\'f3, e tudo ok.\line \line Se a pilha n\u227\'e3o for vazia, vamos achar o \u250\'faltimo elemento atrav\u233\'e9s de um ponteiro *tmp que vai apontar para o primeiro elemento da pilha (PILHA->prox aponta para o primeiro n\u243\'f3).\line \line E como sabemos que o n\u243\'f3 atual \u233\'e9 o \u250\'faltimo?\line Basta checar seu ponteiro *prox, se ele apontar para NULL, ele \u233\'e9 \u250\'faltimo.\line Se n\u227\'e3o apontar, \u233\'e9 porque aponta para um novo n\u243\'f3, ent\u227\'e3o fazemos nosso ponteiro *tmp apontar para este novo n\u243\'f3, sempre, at\u233\'e9 chegar no \u250\'faltimo.\line \line Quando "tmp->prox" apontar para NULL, \u233\'e9 porque *tmp est\u225\'e1 apontando para o \u250\'faltimo n\u243\'f3.\line Agora, vamos fazer o pr\u243\'f3ximo n\u243\'f3 apontar para nosso novo n\u243\'f3: tmp->prox = novo\line E pronto! Fun\u231\'e7\u227\'e3o push feita! Adicionamos um novo n\u243\'f3 na pilha.}
\par \pard\plain \s3\rtlch\af8\afs28\ab \ltrch\hich\af3\loch\ilvl2\outlinelevel2\sb140\sa120\keepn\f3\fs28\b\dbch\af6\ql\ltrpar{\loch
Fun\u231\'e7\u227\'e3o pop()}
\par \pard\plain \s16\loch\sl276\slmult1\sb0\sa140\ql\sb0\sa0\ltrpar{\loch
Agora vamos para a fun\u231\'e7\u227\'e3o pop, o outro pilar da estrutura de dados din\u226\'e2mica que \u233\'e9 a pilha.\line Esta fun\u231\'e7\u227\'e3o vai tirar o \u250\'faltimo n\u243\'f3 da pilha, e retir\u225\'e1-lo de l\u225\'e1.\line \line Primeiro fazemos uma checagem se a pilha est\u225\'e1 vazia (PILHA->prox aponta pra NULL).\line Se estiver, n\u227\'e3o h\u225\'e1 nada a ser feito, pois n\u227\'e3o h\u225\'e1 n\u243\'f3 para ser retirado da pilha.\line \line Do contr\u225\'e1rio, vamos utilizar dois ponteiros para struct Node, o "ultimo" e o "penultimo".\line Basicamente, o que vamos fazer \u233\'e9 que o "ultimo" aponte para o \u250\'faltimo elemento da pilha e o "penultimo" aponte para o \u250\'faltimo n\u243\'f3 da pilha.}
\par \trowd\trql\ltrrow\trpaddft3\trpaddt0\trpaddfl3\trpaddl0\trpaddfb3\trpaddb0\trpaddfr3\trpaddr0\clvertalc\cellx23\clvertalc\cellx46\pard\plain \s20\loch\nowidctlpar\noline\intbl\ql\ltrpar\rtlch\afs4 \ltrch\loch\fs4\loch
\cell\pard\plain \s20\loch\nowidctlpar\noline\intbl\ql\ltrpar\rtlch\afs4 \ltrch\loch\fs4\loch
\cell\row\pard \pard\plain \s16\loch\sl276\slmult1\sb0\sa140\ql\sb0\sa0\ltrpar{\loch
\line O motivo disso \u233\'e9 simples: vamos retornar o \u250\'faltimo n\u243\'f3 da pilha e vamos retir\u225\'e1-lo da lista (ent\u227\'e3o ele vai se perder, por isso precisaremos sempre do pen\u250\'faltimo, pois este vai se tornar o novo \u250\'faltimo n\u243\'f3 da lista).\line \line O que vamos fazer \u233\'e9 buscar o \u250\'faltimo n\u243\'f3 (que \u233\'e9 aquele que tem o ponteiro *prox apontando pra NULL).\line E sempre que avan\u231\'e7armos na pilha com o ponteiro "ultimo", fazemos com que o "penultimo" tamb\u233\'e9m avance (ora, o pen\u250\'faltimo n\u243\'f3 \u233\'e9 aquele que tem o ponteiro *prox apontando para o ponteiro *ultimo).\line \line Essa l\u243\'f3gica \u233\'e9 feita testando ultima->prox, quando n\u227\'e3o for NULL, o ponteiro "penultimo" passa a ser o "ultimo" e o "ultimo" vai ser o "ultimo->prox", que \u233\'e9 o pr\u243\'f3ximo n\u243\'f3 da pilha.\line Note que agora que demos um passo a frente na pilha, com os dois ponteiros.\line E isso s\u243\'f3 para quando estivermos apontando para o \u250\'faltimo e pen\u250\'faltimo n\u243\'f3 da pilha.\line \line Quando estivermos nesse ponto, fazemos "penultimo->prox" apontar para NULL, pois vai caracterizar que o pen\u250\'faltimo n\u243\'f3 ser\u225\'e1, agora, o \u250\'faltimo n\u243\'f3 (pois aponta pra NULL), ou seja: retiramos o \u250\'faltimo n\u243\'f3 da pilha!\line \line E o que fazemos com o \u250\'faltimo n\u243\'f3?\line Vamos retornar ele! Se estamos tirando ele da pilha, \u233\'e9 porque queremos o que tem nele, seja l\u225\'e1 pra que for. Ent\u227\'e3o retornamos ele pra fun\u231\'e7\u227\'e3o que o chamou (a fun\u231\'e7\u227\'e3o opcao()), ela exibe o valor desse \u250\'faltimo elemento da pilha e ent\u227\'e3o o descarta (liberando a mem\u243\'f3ria dele).}
\par \pard\plain \s0\rtlch\af8\afs24\alang1081 \ltrch\lang1046\langfe2052\hich\af3\loch\nowidctlpar\hyphpar0\ltrpar\cf0\f3\fs24\lang1046\kerning1\dbch\af6\langfe2052\ql\ltrpar\loch

\par }